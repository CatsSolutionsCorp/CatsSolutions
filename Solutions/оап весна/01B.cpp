/**
⠄⠄⠄⠄⠄⠄⠄⠄⣠⣴⠶⠿⠛⠛⠛⠛⠛⠛⠷⠶⢶⣤⣀⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
⠄⠄⠄⠄⠄⣤⣶⠟⠉⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠈⠛⢿⣶⣤⠄⠄⠄⠄⠄⠄⠄⠄
⠄⠄⠄⣠⣾⠟⠁⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠻⣿⣿⣦⡀⠄⠄⠄⠄⠄
⠄⠄⣼⣿⠋⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠹⣿⣿⣿⣆⠄⠄⠄⠄
⠄⣸⣿⡇⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⢸⣿⣿⣿⣧⡀⠄⠄
⢰⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⢰⣿⣿⣿⣿⣇⠄⠄
⢸⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⡀⠄
⢸⣿⣿⢠⣤⣤⣄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣀⣀⣠⣤⡀⠄⢸⣿⣿⡟⣿⣿⡇⠄
⢸⣿⣿⣿⠏⠛⠛⠿⣷⣶⣄⠄⠄⠄⠄⣠⣴⣾⣿⡿⠟⠛⠛⠛⠛⢦⣼⣿⣿⡔⣾⣿⡇⠄
⠄⢿⣿⡟⢀⣤⣶⣶⠾⢿⣿⣷⠄⠄⢠⣿⣿⢛⡿⢿⣷⡶⠦⣤⣄⡈⢿⣿⣿⣿⣾⣿⠃⠄
⣶⢾⣿⠄⠉⠁⠉⠉⠄⠤⠞⣿⠄⠄⢸⣿⡿⠄⠈⠄⠄⠁⠉⣽⠟⠄⠈⣿⣿⣿⣿⣿⣿⡇
⣿⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠃⠄⠄⢸⣿⡇⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣇⡏⣧
⣿⣿⣿⡇⠄⠄⠄⠄⠄⡴⠄⠣⡀⢀⣸⣿⠿⣷⠄⠄⠄⠄⠄⠄⠄⠄⣠⣿⣿⣿⣿⣿⣿⢸
⢹⣿⣿⣧⠄⠄⠄⠄⠄⠙⠚⣛⡊⣻⣿⡛⠗⠋⠄⠄⠄⠄⠄⠄⠄⢰⣿⣿⣿⣿⣿⣿⠏⡜
⠈⢻⣿⣿⡆⠄⠄⢀⣴⣴⣿⣿⠿⢾⡻⠿⢿⣶⣶⣦⡀⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⣿⡜⠁
⠄⠄⣿⣿⣿⠄⠄⣾⣿⣿⠿⠛⠛⠛⠛⠿⠶⣿⣿⣿⣿⡆⠄⠄⢀⣿⣿⣿⣿⣿⡿⠟⠄⠄
⠄⠄⠄⢹⣿⣄⠄⠉⠁⠄⠳⢶⣶⣶⣶⣶⣾⣿⡟⠃⠄⠁⠄⠄⣼⣿⣿⣿⣿⣏⠄⠄⠄⠄
⠄⠄⠄⠘⣿⣿⣆⣀⣀⡀⡀⡖⣸⣶⣶⣿⣿⣿⣷⣦⡀⠄⢀⣾⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄
⠄⠄⠄⠄⣿⣿⣿⣿⣿⠟⠁⠁⢿⣿⡿⠍⠻⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄
⠄⠄⠄⣼⣿⣿⡿⣿⣿⣴⠄⠰⣿⣿⣇⢀⠄⠸⣿⣿⣿⣿⣿⣿⠟⣿⣿⣿⣿⣿⡀⠄⠄⠄
⠄⠄⠘⠿⣿⣿⣿⣀⠙⠿⣷⣤⣼⣿⣿⣾⣷⣾⣿⡿⠟⠋⠉⠄⠄⣿⣿⣿⣿⣿⠇⠄⠄⠄
⠄⠄⠄⠄⠈⠛⠿⣿⣶⣤⡈⠛⢿⣿⣿⠿⠛⠉⠁⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⠄⠄⠄⠄
⠄⠄⠄⠄⠄⠄⠄⠈⠛⠿⣿⣿⣦⣤⣀⡀⠄⠄⠄⠄⠄⠄⠄⠄⢘⣿⣿⣿⣿⡿⠄⠄⠄⠄
⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠉⠉⠛⠻⠿⠿⢶⣦⣄⣀⣀⣀⣀⣼⡿⠿⠿⠛⠁⠄⠄⠄⠄
*****************************************
*        Copyrighted by SE04#0556       *
*****************************************
**/

#include <fstream>
#include <string>
#include <iostream>

unsigned long long global_counter = 0;
struct soldier {
    double height;
    std::string name;
};

void merge(soldier *array, int const left, int const mid, int const right) {
    int size_of_sub_array_left = mid - left + 1;
    int size_of_sub_array_right = right - mid;
    soldier left_array[size_of_sub_array_left], right_array[size_of_sub_array_right];
    for (int i = 0; i < size_of_sub_array_left; i++)
        left_array[i] = array[left + i];
    for (int j = 0; j < size_of_sub_array_right; j++)
        right_array[j] = array[mid + 1 + j];
    int current_index_of_left_sub_array = 0, current_index_of_right_sub_array = 0;
    int current_index_of_answer_array = left;

    //соединяем, пока не дойдём до конца левого или правого массива
    while (current_index_of_left_sub_array < size_of_sub_array_left and current_index_of_right_sub_array < size_of_sub_array_right)
        if (left_array[current_index_of_left_sub_array].height >= right_array[current_index_of_right_sub_array].height)
            array[current_index_of_answer_array++] = left_array[current_index_of_left_sub_array++];
        else {
            array[current_index_of_answer_array++] = right_array[current_index_of_right_sub_array++];
            global_counter += size_of_sub_array_left - current_index_of_left_sub_array;
        }

    //доводим до конца тот массив, в котором не дошли
    while (current_index_of_left_sub_array < size_of_sub_array_left)
        array[current_index_of_answer_array++] = left_array[current_index_of_left_sub_array++];
    while (current_index_of_right_sub_array < size_of_sub_array_right)
        array[current_index_of_answer_array++] = right_array[current_index_of_right_sub_array++];
}

void MergeSort(soldier *array, int const begin, int const end) {
    if (begin >= end)
        return;

    int mid = begin + (end - begin) / 2;
    MergeSort(array, begin, mid);
    MergeSort(array, mid + 1, end);
    merge(array, begin, mid, end);
}

int mainA2() {
    std::ifstream input("input.txt");
    std::ofstream output("output.txt");
    int number_of_soldiers;
    input >> number_of_soldiers;
    soldier army[number_of_soldiers];
    for (int i = 0; i < number_of_soldiers; i++)
        input >> army[i].height >> army[i].name;
    input.close();

    MergeSort(army, 0, number_of_soldiers - 1);

    output << global_counter;
    output.close();
    return 0;
}