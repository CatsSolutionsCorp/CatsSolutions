/**
⠄⠄⠄⠄⠄⠄⠄⠄⣠⣴⠶⠿⠛⠛⠛⠛⠛⠛⠷⠶⢶⣤⣀⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
⠄⠄⠄⠄⠄⣤⣶⠟⠉⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠈⠛⢿⣶⣤⠄⠄⠄⠄⠄⠄⠄⠄
⠄⠄⠄⣠⣾⠟⠁⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠻⣿⣿⣦⡀⠄⠄⠄⠄⠄
⠄⠄⣼⣿⠋⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠹⣿⣿⣿⣆⠄⠄⠄⠄
⠄⣸⣿⡇⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⢸⣿⣿⣿⣧⡀⠄⠄
⢰⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⢰⣿⣿⣿⣿⣇⠄⠄
⢸⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⡀⠄
⢸⣿⣿⢠⣤⣤⣄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣀⣀⣠⣤⡀⠄⢸⣿⣿⡟⣿⣿⡇⠄
⢸⣿⣿⣿⠏⠛⠛⠿⣷⣶⣄⠄⠄⠄⠄⣠⣴⣾⣿⡿⠟⠛⠛⠛⠛⢦⣼⣿⣿⡔⣾⣿⡇⠄
⠄⢿⣿⡟⢀⣤⣶⣶⠾⢿⣿⣷⠄⠄⢠⣿⣿⢛⡿⢿⣷⡶⠦⣤⣄⡈⢿⣿⣿⣿⣾⣿⠃⠄
⣶⢾⣿⠄⠉⠁⠉⠉⠄⠤⠞⣿⠄⠄⢸⣿⡿⠄⠈⠄⠄⠁⠉⣽⠟⠄⠈⣿⣿⣿⣿⣿⣿⡇
⣿⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠃⠄⠄⢸⣿⡇⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣇⡏⣧
⣿⣿⣿⡇⠄⠄⠄⠄⠄⡴⠄⠣⡀⢀⣸⣿⠿⣷⠄⠄⠄⠄⠄⠄⠄⠄⣠⣿⣿⣿⣿⣿⣿⢸
⢹⣿⣿⣧⠄⠄⠄⠄⠄⠙⠚⣛⡊⣻⣿⡛⠗⠋⠄⠄⠄⠄⠄⠄⠄⢰⣿⣿⣿⣿⣿⣿⠏⡜
⠈⢻⣿⣿⡆⠄⠄⢀⣴⣴⣿⣿⠿⢾⡻⠿⢿⣶⣶⣦⡀⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⣿⡜⠁
⠄⠄⣿⣿⣿⠄⠄⣾⣿⣿⠿⠛⠛⠛⠛⠿⠶⣿⣿⣿⣿⡆⠄⠄⢀⣿⣿⣿⣿⣿⡿⠟⠄⠄
⠄⠄⠄⢹⣿⣄⠄⠉⠁⠄⠳⢶⣶⣶⣶⣶⣾⣿⡟⠃⠄⠁⠄⠄⣼⣿⣿⣿⣿⣏⠄⠄⠄⠄
⠄⠄⠄⠘⣿⣿⣆⣀⣀⡀⡀⡖⣸⣶⣶⣿⣿⣿⣷⣦⡀⠄⢀⣾⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄
⠄⠄⠄⠄⣿⣿⣿⣿⣿⠟⠁⠁⢿⣿⡿⠍⠻⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄
⠄⠄⠄⣼⣿⣿⡿⣿⣿⣴⠄⠰⣿⣿⣇⢀⠄⠸⣿⣿⣿⣿⣿⣿⠟⣿⣿⣿⣿⣿⡀⠄⠄⠄
⠄⠄⠘⠿⣿⣿⣿⣀⠙⠿⣷⣤⣼⣿⣿⣾⣷⣾⣿⡿⠟⠋⠉⠄⠄⣿⣿⣿⣿⣿⠇⠄⠄⠄
⠄⠄⠄⠄⠈⠛⠿⣿⣶⣤⡈⠛⢿⣿⣿⠿⠛⠉⠁⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⠄⠄⠄⠄
⠄⠄⠄⠄⠄⠄⠄⠈⠛⠿⣿⣿⣦⣤⣀⡀⠄⠄⠄⠄⠄⠄⠄⠄⢘⣿⣿⣿⣿⡿⠄⠄⠄⠄
⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠉⠉⠛⠻⠿⠿⢶⣦⣄⣀⣀⣀⣀⣼⡿⠿⠿⠛⠁⠄⠄⠄⠄
*****************************************
*        Copyrighted by SE04#0556       *
*****************************************
**/

#include <fstream>
#include <string>
#include <iostream>

void build_tree(int *starting_array, int *tree_array, int size_of_array_or_right_tree_boundary, int current_vertex = 1,
                int left_tree_boundary = 0) {
    if (left_tree_boundary == size_of_array_or_right_tree_boundary)
        tree_array[current_vertex] = left_tree_boundary;
    else {
        int middle_of_tree = (left_tree_boundary + size_of_array_or_right_tree_boundary) / 2;
        build_tree(starting_array, tree_array, middle_of_tree, current_vertex * 2, left_tree_boundary);
        build_tree(starting_array, tree_array, size_of_array_or_right_tree_boundary, current_vertex * 2 + 1, middle_of_tree + 1);
        if (starting_array[tree_array[current_vertex * 2]] >= starting_array[tree_array[current_vertex * 2 + 1]])
            tree_array[current_vertex] = tree_array[current_vertex * 2];
        else tree_array[current_vertex] = tree_array[current_vertex * 2 + 1];
    }
}

int get_max(int *starting_array, int *tree_array, int left_index_boundary_of_search, int right_index_boundary_of_search,
            int size_of_array_or_right_tree_boundary, int current_vertex = 1, int left_tree_boundary = 0) {
    if (left_index_boundary_of_search <= left_tree_boundary and
        size_of_array_or_right_tree_boundary <= right_index_boundary_of_search)
        return starting_array[tree_array[current_vertex]];
    if (size_of_array_or_right_tree_boundary < left_index_boundary_of_search or
        right_index_boundary_of_search < left_tree_boundary)
        return 0;
    int middle_of_tree = (left_tree_boundary + size_of_array_or_right_tree_boundary) / 2;
    return std::max(get_max(starting_array, tree_array, left_index_boundary_of_search, right_index_boundary_of_search,
                            current_vertex * 2, left_tree_boundary, middle_of_tree),
                    get_max(starting_array, tree_array, left_index_boundary_of_search, right_index_boundary_of_search,
                            current_vertex * 2 + 1, middle_of_tree + 1, size_of_array_or_right_tree_boundary));
}

void update(int *starting_array, int *tree_array, int original_array_index, int new_value,
            int size_of_array_or_right_tree_boundary, int current_vertex = 1, int left_tree_boundary = 0) {
    if (original_array_index <= left_tree_boundary and size_of_array_or_right_tree_boundary <= original_array_index) {
        starting_array[original_array_index] = new_value;
        tree_array[current_vertex] = original_array_index;
        return;
    }
    if (size_of_array_or_right_tree_boundary < original_array_index or original_array_index < left_tree_boundary)
        return;
    int middle_of_tree = (left_tree_boundary + size_of_array_or_right_tree_boundary) / 2;
    update(starting_array, tree_array, original_array_index, new_value, middle_of_tree, current_vertex * 2,
           left_tree_boundary);
    update(starting_array, tree_array, original_array_index, new_value, size_of_array_or_right_tree_boundary,
           current_vertex * 2 + 1, middle_of_tree + 1);
    if (starting_array[tree_array[current_vertex * 2]] >= starting_array[tree_array[current_vertex * 2 + 1]])
        tree_array[current_vertex] = tree_array[current_vertex * 2];
    else tree_array[current_vertex] = tree_array[current_vertex * 2 + 1];
}

int main() {
    std::ifstream input("input.txt");
    std::ofstream output("output.txt");
    int number_of_workers, number_of_changes;
    input >> number_of_workers >> number_of_changes;
    int workers[number_of_workers];
    for (int i = 0; i < number_of_workers; i++)
        input >> workers[i];

    int tree[number_of_workers * 4];
    for (int i = 0; i < number_of_workers; i++)
        tree[i] = -1;
    build_tree(workers, tree, number_of_workers - 1);
    int number_of_updated_worker, change;
    for (int i = 0; i < number_of_changes; i++) {
        input >> number_of_updated_worker >> change;
        update(workers, tree, number_of_updated_worker - 1, workers[number_of_updated_worker - 1] + change, number_of_workers - 1);
        output << workers[tree[1]] << '\n';
    }


    output.close();
    return 0;
}