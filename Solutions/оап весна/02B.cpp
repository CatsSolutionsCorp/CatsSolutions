/**
⠄⠄⠄⠄⠄⠄⠄⠄⣠⣴⠶⠿⠛⠛⠛⠛⠛⠛⠷⠶⢶⣤⣀⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
⠄⠄⠄⠄⠄⣤⣶⠟⠉⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠈⠛⢿⣶⣤⠄⠄⠄⠄⠄⠄⠄⠄
⠄⠄⠄⣠⣾⠟⠁⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠻⣿⣿⣦⡀⠄⠄⠄⠄⠄
⠄⠄⣼⣿⠋⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠹⣿⣿⣿⣆⠄⠄⠄⠄
⠄⣸⣿⡇⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⢸⣿⣿⣿⣧⡀⠄⠄
⢰⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⢰⣿⣿⣿⣿⣇⠄⠄
⢸⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⡀⠄
⢸⣿⣿⢠⣤⣤⣄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣀⣀⣠⣤⡀⠄⢸⣿⣿⡟⣿⣿⡇⠄
⢸⣿⣿⣿⠏⠛⠛⠿⣷⣶⣄⠄⠄⠄⠄⣠⣴⣾⣿⡿⠟⠛⠛⠛⠛⢦⣼⣿⣿⡔⣾⣿⡇⠄
⠄⢿⣿⡟⢀⣤⣶⣶⠾⢿⣿⣷⠄⠄⢠⣿⣿⢛⡿⢿⣷⡶⠦⣤⣄⡈⢿⣿⣿⣿⣾⣿⠃⠄
⣶⢾⣿⠄⠉⠁⠉⠉⠄⠤⠞⣿⠄⠄⢸⣿⡿⠄⠈⠄⠄⠁⠉⣽⠟⠄⠈⣿⣿⣿⣿⣿⣿⡇
⣿⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠃⠄⠄⢸⣿⡇⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣇⡏⣧
⣿⣿⣿⡇⠄⠄⠄⠄⠄⡴⠄⠣⡀⢀⣸⣿⠿⣷⠄⠄⠄⠄⠄⠄⠄⠄⣠⣿⣿⣿⣿⣿⣿⢸
⢹⣿⣿⣧⠄⠄⠄⠄⠄⠙⠚⣛⡊⣻⣿⡛⠗⠋⠄⠄⠄⠄⠄⠄⠄⢰⣿⣿⣿⣿⣿⣿⠏⡜
⠈⢻⣿⣿⡆⠄⠄⢀⣴⣴⣿⣿⠿⢾⡻⠿⢿⣶⣶⣦⡀⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⣿⡜⠁
⠄⠄⣿⣿⣿⠄⠄⣾⣿⣿⠿⠛⠛⠛⠛⠿⠶⣿⣿⣿⣿⡆⠄⠄⢀⣿⣿⣿⣿⣿⡿⠟⠄⠄
⠄⠄⠄⢹⣿⣄⠄⠉⠁⠄⠳⢶⣶⣶⣶⣶⣾⣿⡟⠃⠄⠁⠄⠄⣼⣿⣿⣿⣿⣏⠄⠄⠄⠄
⠄⠄⠄⠘⣿⣿⣆⣀⣀⡀⡀⡖⣸⣶⣶⣿⣿⣿⣷⣦⡀⠄⢀⣾⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄
⠄⠄⠄⠄⣿⣿⣿⣿⣿⠟⠁⠁⢿⣿⡿⠍⠻⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄
⠄⠄⠄⣼⣿⣿⡿⣿⣿⣴⠄⠰⣿⣿⣇⢀⠄⠸⣿⣿⣿⣿⣿⣿⠟⣿⣿⣿⣿⣿⡀⠄⠄⠄
⠄⠄⠘⠿⣿⣿⣿⣀⠙⠿⣷⣤⣼⣿⣿⣾⣷⣾⣿⡿⠟⠋⠉⠄⠄⣿⣿⣿⣿⣿⠇⠄⠄⠄
⠄⠄⠄⠄⠈⠛⠿⣿⣶⣤⡈⠛⢿⣿⣿⠿⠛⠉⠁⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⠄⠄⠄⠄
⠄⠄⠄⠄⠄⠄⠄⠈⠛⠿⣿⣿⣦⣤⣀⡀⠄⠄⠄⠄⠄⠄⠄⠄⢘⣿⣿⣿⣿⡿⠄⠄⠄⠄
⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠉⠉⠛⠻⠿⠿⢶⣦⣄⣀⣀⣀⣀⣼⡿⠿⠿⠛⠁⠄⠄⠄⠄
*****************************************
*        Copyrighted by SE04#0556       *
*****************************************
**/

#include <fstream>
#include <string>
#include <iostream>

long long GetMax(const std::pair<long long, long long> *array, int size_of_array) {
    long long maximum = array[0].second;
    for (int i = 1; i < size_of_array; i++)
        if (array[i].second > maximum)
            maximum = array[i].second;
    return maximum;
}

void CountSort(std::pair<long long, long long> *array, int size_of_array, int exp) {
    std::pair<long long, long long> output[size_of_array];
    int count[10] = {};
    for (int i = 0; i < size_of_array; i++)
        count[(array[i].second / exp) % 10]++;
    for (int i = 1; i < 10; i++)
        count[i] += count[i - 1];
    for (int i = size_of_array - 1; i >= 0; i--)
        output[count[(array[i].second / exp) % 10]-- - 1] = array[i];
    for (int i = 0; i < size_of_array; i++)
        array[i] = output[i];
}

void RadixSort(std::pair<long long, long long> *array, int size_of_array) {
    long long max_number = GetMax(array, size_of_array);
    for (int exp = 1; max_number / exp > 0; exp *= 10)
        CountSort(array, size_of_array, exp);
}

void Make_It_Min_Heap_Deletion(long long *array, int size_of_heap, long long current_node) {
    long long smallest = current_node, left_child = 2 * current_node + 1, right_child = 2 * current_node + 2;
    if (right_child < size_of_heap and array[right_child] < array[smallest])
        smallest = right_child;
    if (left_child < size_of_heap and array[left_child] < array[smallest])
        smallest = left_child;
    if (smallest != current_node) {
        std::swap(array[current_node], array[smallest]);
        Make_It_Min_Heap_Deletion(array, size_of_heap, smallest);
    }
}

void Delete_Node_Min_Heap(long long *array, int &size_of_heap) {
    array[0] = array[size_of_heap-- - 1];
    Make_It_Min_Heap_Deletion(array, size_of_heap, 0);
}

void Make_It_Min_Heap_Insertion(long long *array, int size_of_heap, long long current_node) {
    long long parent = (current_node - 1) / 2;
    if (parent >= 0 and array[current_node] < array[parent]) {
        std::swap(array[current_node], array[parent]);
        Make_It_Min_Heap_Insertion(array, size_of_heap, parent);
    }
}

void Insert_Node_Min_Heap(long long *array, int &size_of_heap, long long value) {
    array[size_of_heap++] = value;
    Make_It_Min_Heap_Insertion(array, size_of_heap, size_of_heap - 1);
}

int main() {
    std::ifstream input("power.in");
    std::ofstream output("power.out");
    int number_of_fields, needed_number_of_active_fields, size_of_min_heap = 0;
    input >> number_of_fields >> needed_number_of_active_fields;
    std::pair<long long, long long> fields[number_of_fields];
    long long min_heap_first_parameter[number_of_fields];
    for (int i = 0; i < number_of_fields; i++)
        input >> fields[i].first >> fields[i].second;
    input.close();

    RadixSort(fields, number_of_fields);
    unsigned long long answer_area = 0;
    for (int i = number_of_fields - 1; i > -1; i--) {
        Insert_Node_Min_Heap(min_heap_first_parameter, size_of_min_heap, fields[i].first);
        if (size_of_min_heap > needed_number_of_active_fields)
            Delete_Node_Min_Heap(min_heap_first_parameter, size_of_min_heap);
        if (size_of_min_heap == needed_number_of_active_fields and
            answer_area < fields[i].second * min_heap_first_parameter[0])
            answer_area = fields[i].second * min_heap_first_parameter[0];
    }

    output << answer_area;
    return 0;
}