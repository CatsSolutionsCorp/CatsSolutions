/**
⠄⠄⠄⠄⠄⠄⠄⠄⣠⣴⠶⠿⠛⠛⠛⠛⠛⠛⠷⠶⢶⣤⣀⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
⠄⠄⠄⠄⠄⣤⣶⠟⠉⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠈⠛⢿⣶⣤⠄⠄⠄⠄⠄⠄⠄⠄
⠄⠄⠄⣠⣾⠟⠁⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠻⣿⣿⣦⡀⠄⠄⠄⠄⠄
⠄⠄⣼⣿⠋⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠹⣿⣿⣿⣆⠄⠄⠄⠄
⠄⣸⣿⡇⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⢸⣿⣿⣿⣧⡀⠄⠄
⢰⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⢰⣿⣿⣿⣿⣇⠄⠄
⢸⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⡀⠄
⢸⣿⣿⢠⣤⣤⣄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣀⣀⣠⣤⡀⠄⢸⣿⣿⡟⣿⣿⡇⠄
⢸⣿⣿⣿⠏⠛⠛⠿⣷⣶⣄⠄⠄⠄⠄⣠⣴⣾⣿⡿⠟⠛⠛⠛⠛⢦⣼⣿⣿⡔⣾⣿⡇⠄
⠄⢿⣿⡟⢀⣤⣶⣶⠾⢿⣿⣷⠄⠄⢠⣿⣿⢛⡿⢿⣷⡶⠦⣤⣄⡈⢿⣿⣿⣿⣾⣿⠃⠄
⣶⢾⣿⠄⠉⠁⠉⠉⠄⠤⠞⣿⠄⠄⢸⣿⡿⠄⠈⠄⠄⠁⠉⣽⠟⠄⠈⣿⣿⣿⣿⣿⣿⡇
⣿⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠃⠄⠄⢸⣿⡇⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣇⡏⣧
⣿⣿⣿⡇⠄⠄⠄⠄⠄⡴⠄⠣⡀⢀⣸⣿⠿⣷⠄⠄⠄⠄⠄⠄⠄⠄⣠⣿⣿⣿⣿⣿⣿⢸
⢹⣿⣿⣧⠄⠄⠄⠄⠄⠙⠚⣛⡊⣻⣿⡛⠗⠋⠄⠄⠄⠄⠄⠄⠄⢰⣿⣿⣿⣿⣿⣿⠏⡜
⠈⢻⣿⣿⡆⠄⠄⢀⣴⣴⣿⣿⠿⢾⡻⠿⢿⣶⣶⣦⡀⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⣿⡜⠁
⠄⠄⣿⣿⣿⠄⠄⣾⣿⣿⠿⠛⠛⠛⠛⠿⠶⣿⣿⣿⣿⡆⠄⠄⢀⣿⣿⣿⣿⣿⡿⠟⠄⠄
⠄⠄⠄⢹⣿⣄⠄⠉⠁⠄⠳⢶⣶⣶⣶⣶⣾⣿⡟⠃⠄⠁⠄⠄⣼⣿⣿⣿⣿⣏⠄⠄⠄⠄
⠄⠄⠄⠘⣿⣿⣆⣀⣀⡀⡀⡖⣸⣶⣶⣿⣿⣿⣷⣦⡀⠄⢀⣾⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄
⠄⠄⠄⠄⣿⣿⣿⣿⣿⠟⠁⠁⢿⣿⡿⠍⠻⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄
⠄⠄⠄⣼⣿⣿⡿⣿⣿⣴⠄⠰⣿⣿⣇⢀⠄⠸⣿⣿⣿⣿⣿⣿⠟⣿⣿⣿⣿⣿⡀⠄⠄⠄
⠄⠄⠘⠿⣿⣿⣿⣀⠙⠿⣷⣤⣼⣿⣿⣾⣷⣾⣿⡿⠟⠋⠉⠄⠄⣿⣿⣿⣿⣿⠇⠄⠄⠄
⠄⠄⠄⠄⠈⠛⠿⣿⣶⣤⡈⠛⢿⣿⣿⠿⠛⠉⠁⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⠄⠄⠄⠄
⠄⠄⠄⠄⠄⠄⠄⠈⠛⠿⣿⣿⣦⣤⣀⡀⠄⠄⠄⠄⠄⠄⠄⠄⢘⣿⣿⣿⣿⡿⠄⠄⠄⠄
⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠉⠉⠛⠻⠿⠿⢶⣦⣄⣀⣀⣀⣀⣼⡿⠿⠿⠛⠁⠄⠄⠄⠄
*****************************************
*        Copyrighted by SE04#0556       *
*****************************************
**/

#include <fstream>
#include <string>
#include <iostream>

struct teh_urn {
    int team_number;
    int problem_number;
    long long submission_time;
    int accepted;

    bool operator<=(const teh_urn &second) const {
        if (team_number != second.team_number)
            return team_number < second.team_number;
        else if (problem_number != second.problem_number)
            return problem_number < second.problem_number;
        else return submission_time <= second.submission_time;
    }
};

struct team {
    int number_of_solved = 0;
    long long total_time = 0;
    int original_number;

    bool operator<=(const team &second) const {
        if (number_of_solved != second.number_of_solved)
            return number_of_solved > second.number_of_solved;
        else return total_time <= second.total_time;
    }
};

template<class run_or_team>
void merge(run_or_team *array, int const left, int const mid, int const right) {
    int size_of_sub_array_left = mid - left + 1;
    int size_of_sub_array_right = right - mid;
    run_or_team left_array[size_of_sub_array_left], right_array[size_of_sub_array_right];
    for (int i = 0; i < size_of_sub_array_left; i++)
        left_array[i] = array[left + i];
    for (int j = 0; j < size_of_sub_array_right; j++)
        right_array[j] = array[mid + 1 + j];
    int current_index_of_left_sub_array = 0, current_index_of_right_sub_array = 0;
    int current_index_of_answer_array = left;

    //соединяем, пока не дойдём до конца левого или правого массива
    while (current_index_of_left_sub_array < size_of_sub_array_left and
           current_index_of_right_sub_array < size_of_sub_array_right)
        if (left_array[current_index_of_left_sub_array] <= right_array[current_index_of_right_sub_array])
            array[current_index_of_answer_array++] = left_array[current_index_of_left_sub_array++];
        else
            array[current_index_of_answer_array++] = right_array[current_index_of_right_sub_array++];

    //доводим до конца тот массив, в котором не дошли
    while (current_index_of_left_sub_array < size_of_sub_array_left)
        array[current_index_of_answer_array++] = left_array[current_index_of_left_sub_array++];
    while (current_index_of_right_sub_array < size_of_sub_array_right)
        array[current_index_of_answer_array++] = right_array[current_index_of_right_sub_array++];
}

template<class run_or_team>
void MergeSort(run_or_team *array, int const begin, int const end) {
    if (begin >= end)
        return;

    int mid = begin + (end - begin) / 2;
    MergeSort(array, begin, mid);
    MergeSort(array, mid + 1, end);
    merge(array, begin, mid, end);
}

int main() {
    std::ifstream input("input.txt");
    std::ofstream output("output.txt");
    int number_of_teams, number_of_runs;
    input >> number_of_teams >> number_of_runs;
    teh_urn runs[number_of_runs + 1];
    runs[number_of_runs].team_number = -1;
    runs[number_of_runs].problem_number = -1;
    team teams[number_of_teams];
    for (int i = 0; i < number_of_teams; i++)
        teams[i].original_number = i + 1;
    for (int i = 0; i < number_of_runs; i++)
        input >> runs[i].team_number >> runs[i].problem_number >> runs[i].submission_time >> runs[i].accepted;
    input.close();

    MergeSort(runs, 0, number_of_runs - 1);

    long long counter_of_failed = 0, taken_time;
    bool is_accepted = false;
    //Так как сравнения в цикле происходят с предыдущей попыткой, то надо прописать частный случай для него
    if (runs[0].accepted == 1) {
        is_accepted = true;
        taken_time = runs[0].submission_time;
    } else
        counter_of_failed++;

    for (int i = 1; i < number_of_runs + 1; i++) {
        if (runs[i].problem_number != runs[i - 1].problem_number or runs[i].team_number != runs[i - 1].team_number) {
            if (is_accepted) {
                teams[runs[i - 1].team_number - 1].number_of_solved++;
                teams[runs[i - 1].team_number - 1].total_time += taken_time + counter_of_failed * 1200;
                is_accepted = false;
            }
            counter_of_failed = 0;
            if (runs[i].accepted == 1) {
                is_accepted = true;
                taken_time = runs[i].submission_time;
            } else
                counter_of_failed++;
        } else {
            if (runs[i].accepted == 1 and not(is_accepted)) {
                is_accepted = true;
                taken_time = runs[i].submission_time;
            } else if (not(is_accepted))
                counter_of_failed++;
        }
    }

    MergeSort(teams, 0, number_of_teams - 1);

    for (int i = 0; i < number_of_teams; i++)
        output << teams[i].original_number << ' ';
    output.close();
    return 0;
}